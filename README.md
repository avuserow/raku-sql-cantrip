[![Actions Status](https://github.com/avuserow/raku-sql-cantrip/workflows/test/badge.svg)](https://github.com/avuserow/raku-sql-cantrip/actions)

NAME
====

SQL::Cantrip - generate simple SQL statements

SYNOPSIS
========

```raku
use SQL::Cantrip;

my $sql = SQL::Cantrip.new;

# Insert values
my $stmt = $sql.insert("users", {:$name, :$email});
$db.execute($stmt.sql, $stmt.bind);

# Select values
my $stmt = $sql.select("users", [:name<CoolDude>], :cols<name email>);
my @users = $db.execute($stmt.sql, $stmt.bind).allrows;

# Update values
my $stmt = $sql.update("users", {:email($new-email)}, [:name<CoolDude>]);
$db.execute($stmt.sql, $stmt.bind);

# Delete values
my $stmt = $sql.delete("users", [:name<CoolDude>]);
$db.execute($stmt.sql, $stmt.bind);
```

DESCRIPTION
===========

SQL::Cantrip is a module for generating SQL statements from lists of Raku values, with helper methods to indicate other operators and parenthesized groups.

This module aims to make it easy and safe to do simple operations with varying columns, such as for a search form allowing users to specify multiple columns to search.

SQL::Cantrip is not an ORM. This may work better for simple applications or when you want to avoid having an object per row.

SQL::Cantrip does not try to support many parts of SQL. Handwritten SQL can be more reliable and clearer for more complex queries. SQL::Cantrip does provide a `where` method, which generates a `WHERE` clause that can be combined with handwritten SQL.

ATTRIBUTES
==========

Attributes for SQL::Cantrip.

quote-identifier
----------------

Quote character to use around column names and other identifiers. Defaults to double quotes (`"`).

SQL GENERATION METHODS
======================

select(Str $table, @where, :$cols)
----------------------------------

Generate a `SELECT` statement for the provided `$table`. The `@where` parameter is passed to the `where` method, see below for usage. .

`$cols` is an optional parameter that is either a Str or a list of Strs. If provided, these are quoted and used as columns to select. Otherwise, `*` is used.

This method returns a `Statement` object, documented below.

insert(Str $table, %set)
------------------------

Generate an `INSERT` statement for the provided `$table`. The hash `%set` provides the columns to update with their corresponding values as key/value pairs.

This method returns a `Statement` object, documented below.

update(Str $table, %set, @where)
--------------------------------

Generate an `UPDATE` statement for the provided `$table`. Like `insert`, it takes a hash `%set` of columns and their new values. Like `select`, the `@where` value is passed to the `where` method, documented below.

The `@where` clause is required. If you intend to update the entire table, pass an empty list.

This method returns a `Statement` object, documented below.

delete(Str $table, @where)
--------------------------

Generate a `DELETE` statement for the provided `$table`. Like `select`, the `@where` value is passed to the `where` method, documented below.

The `@where` clause is required. If you intend to delete all rows in the table, pass an empty list.

This method returns a `Statement` object, documented below.

where(@where)
-------------

This method generates a `WHERE` clause. It takes a list of values and joins them together with `AND`. To use `OR` instead, use a `group`.

The where clause syntax is a list of values. `Pair`s are used for comparing for equality (or checking null). Other comparisons (and parenthesized groups) are generated by helper methods.

To provide more safety, these helper methods all return objects, which protects against a potential trap when accepting JSON values directly (see [http://blog.kazuhooku.com/2014/07/the-json-sql-injection-vulnerability.html](http://blog.kazuhooku.com/2014/07/the-json-sql-injection-vulnerability.html) for details). As a benefit, these helper methods also allow for better error reporting.

Values are processed as following:

### Pair

Pairs are simple equality comparisons for the given column (the key) and the value (the value). This generates SQL of the form `"column" = ?` (with `column` quoted appropriately, and with `value` in the bind parameters).

If the Pair's value is not defined, then the SQL is instead `"column" IS NULL`.

### compare($column, $operator, $value) method call

Use the `compare($column, $operator, $value)` method to compare using the provided operator. In general, this SQL is in the form `"column" $operator ?` (with `column` quoted appropriately, and with `value` in the bind parameters).

See `compare` documentation below for more on the operators.

### group(@where, :and | :or)

Use the `group()` method to make a parenthesized group of items, joined by either `AND` or `OR` depending whether `:and` or `:or` is passed. The `@where` value here is passed recursively into the `where()` method.

The `where` method returns a `Statement` object, documented below.

METHODS FOR WHERE CLAUSES
=========================

group(@where, :or)
------------------

Generate a parenthesized group in a `where` clause, joined by `OR` rather than the default of `AND`.

group(@where, :and)
-------------------

Generate a parenthesized group in a `where` clause, joined by `AND`.

compare($column, $operator, $value)
-----------------------------------

Generate a comparison in a `where` clause using the specified operator. The following operators are permitted:

Standard comparison operators: `< `, `<= `, `=`, `!=`, `>= `, `> `, `IS`, `LIKE`, `NOT LIKE`, `IS NOT`. If `$value` is defined, generates `"$column" $operator ?` (and puts `$value` into the bind list), otherwise generates `"$column" $operator NULL`.

The PostgreSQL operators `ILIKE` and `NOT ILIKE`, which are case-insensitive versions of `LIKE`, otherwise same as above

The operators `IN` and `NOT IN`: treats `$value` as a List and generates a bind query for each value. Does not handle `NULL` specially. Generates `"$column" IN (?, ?, ?)` (for a three element `$value`, for instance).

The operators `BETWEEN` and `NOT BETWEEN`: treats `$value` as a List of exactly two elements and generates a bind query for each value. Does not handle `NULL` specially. Generates `"$column" BETWEEN ? AND ?`.

OTHER CLASSES
=============

Statement
---------

All methods return an instance of this class. It has two public attributes:

  * `sql` - the generated SQL

  * `bind` - list of bound parameters

This is meant to be used directly with a database handle (such as from `DBIish`):

    my $stmt = $sql.insert("users", %user-data);
    $db.execute($stmt.sql, $stmt.bind);

AUTHOR
======

Adrian Kreher <avuserow@gmail.com>

COPYRIGHT AND LICENSE
=====================

Copyright 2021 Adrian Kreher

This library is free software; you can redistribute it and/or modify it under the Artistic License 2.0.

